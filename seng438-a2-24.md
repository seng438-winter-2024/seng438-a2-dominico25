**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      |  24   |
| -------------- | --- |
| Student Names: |  Ella Boulanger   |
|                |  Kenzie Fjestad   |
|                |  Raina Jugdev   |
|                |  Dominico Mendes   |

# 1 Introduction

In this lab, we further developed our understanding of software testing by testing the Range and Data Utilities class functions. Our goal is to better understand unit testing through the JUnit framework by developing test functions to test 5 methods of each class through black-box testing methods. Before the lab, we knew from the class lectures that black-box testing meant creating test functions only knowing descriptions of methods and not having access to the source code of methods.

# 2 Detailed description of unit test strategy

// including the input partitions you have designed
From rubric: A detailed description of the testing strategy for unit testing and your test-case design approach, i.e., how you used the black-box test-case design techniques equivalence classes, and boundary value analysis. Also list the name of the test cases you have designed and identify which one covers which parts of the strategy (which partition, which class, etc.) Include a discussion about what you feel are the benefits and drawbacks about using mocking.

#### Range Class
For the Range class, the only function with an input value was the contains() function. As a result, it is also the only function able to have partitions and equivalence classes for testing. For this function, strong equivalence class testing and boundary value testing were executed. For equivalence class testing, we developed three test cases/functions to cover values lower than the defined range, within the defined range, and above the defined range. The corresponding test case names are: "testNegativeOutOfRangeValueforMethodContains", "testInRangeValueForMethodContains", and "testPositiveOutOfRangeValueforMethodContains". For boundary value testing, we will create test cases for each of the boundaries for a total of 7 test cases. Three tests will cover the upper boundary, another 3 will cover the lower boundary, and a test will cover a nominal value within the range. The corresponding test case names are: "testBelowUpperBoundaryForMethodContains", "testEqualToUpperBoundaryForMethodContains", "testAboveUpperBoundaryForMethodContains", "testBelowLowerBoundaryForMethodContains", "testEqualToLowerBoundaryForMethodContains", "testAboveLowerBoundaryForMethodContains", and "testNominalValueForMethodContains". For consistency, the same example range will be used across all tests for the Range class. The goal of executing testing in this manner is to cover all of the possible areas where the input might demonstrate failure of the function's intended capabilities. The four remaining functions are getCentralValue(), getLength(), getLowerBound(), and getUpperBound(). All of these functions do not have any input values and only have one test case each that tests the equivalence class for within the desired range. The respective test case names are "testCentralValueShouldBeCorrect", "testLengthShouldBeCorrect", "testMethodGetLowerBound", and "testMethodGetUpperBound". It was decided since these functions only have one equivalence class, that only one test case was also needed. More test cases could only test for different ranges of values, and could not test more of the actual functionality of these methods. Also for this reason, only equivalence class testing could be implemented which is why there are no test cases for boundary value testing for these methods. 


#### Data Utilities Class  
For the Data Utilities class, 


#### Benefits and drawbacks of using mocking
When beginning to write tests for the Data Utilities class it became evident that a different type of testing variable would be necessary, this testing concept would be mocking. Having the ability to set the return values of each of the built-in functions of KeyedValues and Values2D gave us much more control to test specific parts of each datatype object to ensure robust testing. ADD ANOTHER BENEFIT. The main drawback we found when completing tests that used or required mocking was the setup. As it was everybody's first time using mocking there was a slight learning curve which did take some time, however there is sufficient information on this concept available for us to learn from. While you can add a general mock I WILL FINISH THIS LOL

- time to set up each mock for each test


# 3 Test cases developed


#### Range Class
| **Test Case #** | **Test Case Name**  | **Function Being Tested** | **Partition** | **Input** | **Expected Output** | **Description** |
|----------------|----------|-----|-----|-----|-----|-----|
| 1 | testInRangeValueForMethodContains()   | contains()    | -1 < value < 1    | 0 | true | Using an input value within the testing range to apply strong equivalence class testing on the contains() function. |
| 2 | testPositiveOutOfRangeValueForMethodContains()   | contains()    | value >> 1    | 25 | false | Using an input value much greater than the testing range to apply strong equivalence class testing on the contains() function. |
| 3 | testNegativeOutOfRangeValueForMethodContains()   | contains()    | value << -1    | -25 | false | Using an input value much less than the testing range to apply strong equivalence class testing on the contains() function. |
| 4 | testBelowUpperBoundaryForMethodContains()   | contains()    | value > 1    | 0.99 | true | Applying boundary value testing by using an input value just below the upper bound. |
| 5 | testEqualToUpperBoundaryForMethodContains()   | contains()    | value = 1    | 1 | true | Applying boundary value testing by using an input value equal to the upper bound. |
| 6 | testAboveUpperBoundaryForMethodContains()   | contains()    | value < 1    | 1.01 | false | Applying boundary value testing by using an input value just above the upper bound. |
| 7 | testBelowLowerBoundaryForMethodContains()   | contains()    | value < -1    | -1.01 | false | Applying boundary value testing by using an input value just below the lower bound. |
| 8 | testEqualToLowerBoundaryForMethodContains()   | contains()    | value = -1    | -1 | true | Applying boundary value testing by using an input value equal to the lower bound. |
| 9 | testAboveLowerBoundaryForMethodContains()   | contains()    | value < -1    | -0.99 | true | Applying boundary value testing by using an input value just above the lower bound. |
| 10 | testCentralValueShouldBeCorrect()   | getCentralValue()    | -1 < value < 1    | -- | 0 | Testing the getCentralValue() function for the set range -1 < value < 1 |
| 11 | testLengthShouldBeCorrect()   | getLength()    | -1 < value < 1    | -- | 2 | Testing the getLength() function for the set range -1 < value < 1 |
| 12 | testMethodGetLowerBound()   | getLowerBound()    | -1 < value < 1    | -- | -1 | Testing the getLowerBound() function for the set range -1 < value < 1 |
| 13 | testMethodGetUpperBound()   | getUpperBound()    | -1 < value < 1    | -- | 1 | Testing the getUpperBound() function for the set range -1 < value < 1 |

#### Data Utilities Class  
| **Test Case #** | **Test Case Name**  | **Function Being Tested** | **Input** | **Expected Output** | **Description** |
|----------------|----------|-----|-----|-----|-----|
| 1 | testInvalidParameterExceptionThrownWithNullValue() | getCumulativePercentages() | KeyedValues = (0, null), (1, null), (2, null) | Have InvalidParameterException thrown | Testing that invalid input (null), makes function, getCumulativePercentages(), throw correct exception. |
| 2 | testCorrectCumulativePercentageForPositiveIntegers() | getCumulativePercentages() | KeyedValues = (0, 5), (1, 9), (2, 2) | The cumulative percentage of key 0 should be 0.3125, the cumulative percentage of key 1 should be 0.875, the cumulative percentage of key 2 should be 1.0.  | Testing valid integer input with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 3 | testCorrectCumulativePercentageForFloatingPointValues() | getCumulativePercentages() | KeyedValues = (0, 1.3), (1, 4.7), (2, 0.6) | The cumulative percentage of key 0 should be 0.1970, the cumulative percentage of key 1 should be 0.9091, the cumulative percentage of key 2 should be 1.0. | Testing valid floating point input with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 4 | testCorrectCumulativePercentageForNegatives() | getCumulativePercentages() | KeyedValues = (0, -10), (1, -3), (2, -5) | The cumulative percentage of key 0 should be 0.5556, the cumulative percentage of key 1 should be 0.7222, the cumulative percentage of key 2 should be 1.0. | Testing valid negative input with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 5 | testCorrectCumulativePercentageForSinglePair() | getCumulativePercentages() | KeyedValues = (0, 5) | The cumulative percentage of key 0 should be 1.0. | Testing single KeyedValues pair with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 6 | testCumulativePercentageForEmptyData() | getCumulativePercentages() | KeyedValues = () | The item count of the result of getCumulativePercentages() function should also be empty. | Testing empty input with getCumulativePercentages() function, should produce empty KeyedValues object. |
| 7 | testCalcColumnNullObject() | calculateColumnTotal() | (row, col, data) Values2D data = null, int row = 1 | This test should envoke the InvalidParameterException since a null object is passed in instead of a normal Values2D object. | Testing calculateColumnTotal() with an invalid input (null object). |
| 8 | testCalculateColumnTotalForTwoValues() | calculateColumnTotal() | (row, col, data) Values2D data = ((0, 0, 7.5), (0, 1, 7.5), (1, 0, 2.5), (1, 1, 2.5)), int col = 0 | The return value of this function call should be a double type with the value 10.0 since it is calculating the total of the column with index=0. That value is equal to (7.5 + 2.5) | Testing calculateColumnTotal with a valid input of mock data that should add two values in the column specified by index. |
| 9 | testCalculateColTotalForNegativeValues() | calculateColumnTotal() | (row, col, data) Values2D data = ((0, 0, -1), (0, 1, -8), (1, 0, -2), (1, 1, -3), (2, 0, -5), (2, 1, -4)), int col = 1 | The return value of this function call should be a double type with the value -15.0 since it is calculating the total of the column with index=1. That value is equal to (-3 + -4 + -8). | Testing calculateColumnTotal with a valid input that will calculate a total using mock data with negative values. |
| 10 | testCalcColNullDataThrowsException() | calculateColumnTotal() | (row, col, data) Values2D data = (0, 0, null), int col = 0 | Passing in data of an invalid object type (null) should envoke a InvalidParameterException. | Testing calculateColumnTotal with an invalid input to envoke an exception. |
| 11 | testColumnTotalSingleValue() | calculateColumnTotal() | (row, col, data) Values2D data = (0, 0, 3),  int column = 0 | The return value of this function call should be a double type with the value 3.0 since it is calculating the total of the column with index=0. That value is equal to 3.0 | Testing calculateColumnTotal() with a valid input of mock data that should return a single value in the column specified by index. |
| 12 | testCalcRowNullObject() | calculateRowTotal() | (row, col, data) Values2D data = null, int row = 1 | This test should envoke the InvalidParameterException since a null object is passed in instead of a normal Values2D object. | Testing calculateRowTotal() with an invalid input (null object). |
| 13 | testCalculateRowTotalWithTwoDoubleValues() | calculateRowTotal() | (row, col, data) Values2D data = ((0, 0, 7.5), (0, 1, 7.5), (1, 0, 2.5), (1, 1, 2.5)), int row = 0 | The return value of this function call should be a double type with the value 15.0 since it is calculating the total of the row with index=0. That value is equal to (7.5 + 7.5) | Testing calculateRowTotal() with a valid input of mock data that should add two values in the row specified by index. |
| 14 | testRowTotalWithTwoNegatives() | calculateRowTotal() | (row, col, data) Values2D data = ((0, 0, -1), (0, 1, -8), (1, 0, -2), (1, 1, -3), (2, 0, -5), (2, 1, -4)), int row = 2 | The return value of this function call should be a double type with the value -9.0 since it is calculating the total of the row with index=2. That value is equal to (-4 + -5). | Testing calculateRowTotal with a valid input that will calculate a total using mock data with negative values. |
| 15 | testCalcRowNullDataThrowsException() | calculateRowTotal() | (row, col, data) Values2D data = (0, 0, null), int col = 0 | Passing in data of an invalid object type (null) should envoke a InvalidParameterException. | Testing calculateRowTotal with an invalid input to envoke an exception. |
| 16 | testRowTotalSingleValue() | calculateRowTotal() | (row, col, data) Values2D data = (0, 0, 3),  int row = 0 | The return value of this function call should be a double type with the value 3.0 since it is calculating the total of the row with index=0. That value is equal to 3.0 | Testing calculateRowTotal() with a valid input of mock data that should return a single value in the row specified by index. |
| 17 | testValidValueForCreateNumberArray() | createNumberArray() | (data) double[] data = {1.1, 2.2, 3.3} | The return of this function should be an array of type Number | Testing createNumberArray() with valid double values |
| 18 | testEmptyValueForCreateNumberArray() | createNumberArray() | (data) double[] data = {} | The return of this function should be an empty array of type Number | Testing createNumberArray() with an empty data input |
| 19 | testNullValueForCreateNumberArray() | createNumberArray() | (data) double[] data = null | The function should throw an IllegalParameterException | Testing the IllegalParamterException throw with null data |
| 20 | testValidValueForCreateNumberArray2D() | createNumberArray2D() | (data) double[][] = {{1.1, -2.2}, {-3.3, 4.4}} | The return of this function should be an array of type Number | Tesing createNumberArray2D() with valid double values |
| 21 | testEmptyValueForCreateNumberArray2D() | createNumberArray2D() | (data) double[][] = {} | The return of this function should be an empty array of type Number | Tesing createNumberArray2D() with an empty data input |
| 22 | testNullValueForCreateNumberArray2D() | createNumberArray2D() | (data) double[][] = null | The function should throw an IllegalParameterException | Testing the IllegalParamterException throw with null data |





// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

The teamwork was managed by dividing the group into pairs that would test each class. Each of the five functions per class was split up among the pair for testing. One person would be responsible for making tests for three methods and the other was responsible for the remaining two. After the test cases were completed, there was an overall review of the test functions by the whole group. This allowed the whole group to understand both the functions they did and the functions the other group members completed. Overall, work was divided fairly and evenly with every group member having the opportunity to learn of and understand the testing processes for all methods tested across both classes.

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
