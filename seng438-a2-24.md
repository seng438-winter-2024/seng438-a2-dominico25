**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      |  24   |
| -------------- | --- |
| Student Names: |  Ella Boulanger   |
|                |  Kenzie Fjestad   |
|                |  Raina Jugdev   |
|                |  Dominico Mendes   |

# 1 Introduction

In this lab, we further developed our understanding of software testing by testing the Range and Data Utilities class functions. Our goal is to better understand unit testing through the JUnit framework by developing test functions to test 5 methods of each class through black-box testing methods. Before the lab, we knew from the class lectures that black-box testing meant creating test functions only knowing descriptions of methods and not having access to the source code of methods.

# 2 Detailed description of unit test strategy



// including the input partitions you have designed

# 3 Test cases developed


**Range Class**
| **Test Case #** | **Test Case Name**  | **Function Being Tested** | **Partition** | **Input** | **Expected Output** | **Description** |
|----------------|----------|-----|-----|-----|-----|-----|
| 1 | testInRangeValueForMethodContains()   | contains()    | -1 < value < 1    | 0 | true | Using an input value within the testing range to apply strong equivalence class testing on the contains() function. |
| 2 | testPositiveOutOfRangeValueForMethodContains()   | contains()    | value >> 1    | 25 | false | Using an input value much greater than the testing range to apply strong equivalence class testing on the contains() function. |
| 3 | testNegativeOutOfRangeValueForMethodContains()   | contains()    | value << -1    | -25 | false | Using an input value much less than the testing range to apply strong equivalence class testing on the contains() function. |
| 4 | testBelowUpperBoundaryForMethodContains()   | contains()    | value > 1    | 0.99 | true | Applying boundary value testing by using an input value just below the upper bound. |
| 5 | testEqualToUpperBoundaryForMethodContains()   | contains()    | value = 1    | 1 | true | Applying boundary value testing by using an input value equal to the upper bound. |
| 6 | testAboveUpperBoundaryForMethodContains()   | contains()    | value < 1    | 1.01 | false | Applying boundary value testing by using an input value just above the upper bound. |
| 7 | testBelowLowerBoundaryForMethodContains()   | contains()    | value < -1    | -1.01 | false | Applying boundary value testing by using an input value just below the lower bound. |
| 8 | testEqualToLowerBoundaryForMethodContains()   | contains()    | value = -1    | -1 | true | Applying boundary value testing by using an input value equal to the lower bound. |
| 9 | testAboveLowerBoundaryForMethodContains()   | contains()    | value < -1    | -0.99 | true | Applying boundary value testing by using an input value just above the lower bound. |
| 10 | testMethodGetLowerBound()   | getLowerBound()    | --    | -- | -1 | Testing the getLowerBound() function for the set range -1 < value < 1 |
| 11 | testMethodGetUpperBound()   | getUpperBound()    | --    | -- | 1 | Testing the getUpperBound() function for the set range -1 < value < 1 |
| 12 | testCentralValueShouldBeCorrect()   | getCentralValue()    | --    | -- | 0 | Testing the getCentralValue() function for the set range -1 < value < 1 |
| 13 | testLengthShouldBeCorrect()   | getLength()    | --    | -- | 2 | Testing the getLength() function for the set range -1 < value < 1 |

**Data Utilities Class**
| **Test Case #** | **Test Case Name**  | **Function Being Tested** | **Input** | **Expected Output** | **Description** |
|----------------|----------|-----|-----|-----|-----|
| 1 | testInvalidParameterExceptionThrownWithNullValue() | getCumulativePercentages() | KeyedValues = (0, null), (1, null), (2, null) | Have InvalidParameterException thrown | Testing that invalid input (null), makes function, getCumulativePercentages(), throw correct exception. |
| 2 | testCorrectCumulativePercentageForPositiveIntegers() | getCumulativePercentages() | KeyedValues = (0, 5), (1, 9), (2, 2) | The cumulative percentage of key 0 should be 0.3125, the cumulative percentage of key 1 should be 0.875, the cumulative percentage of key 2 should be 1.0.  | Testing valid integer input with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 3 | testCorrectCumulativePercentageForFloatingPointValues() | getCumulativePercentages() | KeyedValues = (0, 1.3), (1, 4.7), (2, 0.6) | The cumulative percentage of key 0 should be 0.1970, the cumulative percentage of key 1 should be 0.9091, the cumulative percentage of key 2 should be 1.0. | Testing valid floating point input with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 4 | testCorrectCumulativePercentageForNegatives() | getCumulativePercentages() | KeyedValues = (0, -10), (1, -3), (2, -5) | The cumulative percentage of key 0 should be 0.5556, the cumulative percentage of key 1 should be 0.7222, the cumulative percentage of key 2 should be 1.0. | Testing valid negative input with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 5 | testCorrectCumulativePercentageForSinglePair() | getCumulativePercentages() | KeyedValues = (0, 5) | The cumulative percentage of key 0 should be 1.0. | Testing single KeyedValues pair with getCumulativePercentages() function, should produce correct KeyedValues object. |
| 6 | testCumulativePercentageForEmptyData() | getCumulativePercentages() | KeyedValues = () | The item count of the result of getCumulativePercentages() function should also be empty. | Testing empty input with getCumulativePercentages() function, should produce empty KeyedValues object. |


// write down the name of the test methods and classes. Organize the based on
the source code method // they test. identify which tests cover which partitions
you have explained in the test strategy section //above

# 4 How the team work/effort was divided and managed

The teamwork was managed by dividing the group into pairs that would test each class. Each of the five functions per class was split up among the pair for testing. One person would be responsible for making tests for three methods and the other was responsible for the remaining two. After the test cases were completed, there was an overall review of the test functions by the whole group. This allowed the whole group to understand both the functions they did and the functions the other group members completed. Overall, work was divided fairly and evenly with every group member having the opportunity to learn of and understand the testing processes for all methods tested across both classes.

# 5 Difficulties encountered, challenges overcome, and lessons learned

Text…

# 6 Comments/feedback on the lab itself

Text…
